#include <iostream>#include <unistd.h>#include "Point.h"#include "Strategy.h"#include "Judge.h"#include <math.h>#include <time.h>#include <stdio.h>#include <stdlib.h>using namespace std;const double c = 0.707, eps = 1e-6;const int maxn = 8000000;int nx, ny, m, n, p;int l[maxn],r[maxn],fa[maxn],win[maxn],tot[maxn],xx[maxn],yy[maxn],re[maxn];bool user[maxn];int** board1;                               //top和board为临时的新的棋盘int top1[12];/*	策略函数接口,该函数被对抗平台调用,每次传入当前状态,要求输出你的落子点,该落子点必须是一个符合游戏规则的落子点,不然对抗平台会直接认为你的程序有误		input: 为了防止对对抗平台维护的数据造成更改，所有传入的参数均为const属性 M, N : 棋盘大小 M - 行数 N - 列数 均从0开始计， 左上角为坐标原点，行用x标记，列用y标记 top : 当前棋盘每一列列顶的实际位置. e.g. 第i列为空,则_top[i] == M, 第i列已满,则_top[i] == 0 _board : 棋盘的一维数组表示, 为了方便使用，在该函数刚开始处，我们已经将其转化为了二维数组board 你只需直接使用board即可，左上角为坐标原点，数组从[0][0]开始计(不是[1][1]) board[x][y]表示第x行、第y列的点(从0开始计) board[x][y] == 0/1/2 分别对应(x,y)处 无落子/有用户的子/有程序的子,不可落子点处的值也为0 lastX, lastY : 对方上一次落子的位置, 你可能不需要该参数，也可能需要的不仅仅是对方一步的 落子位置，这时你可以在自己的程序中记录对方连续多步的落子位置，这完全取决于你自己的策略 noX, noY : 棋盘上的不可落子点(注:涫嫡饫锔?龅膖op已经替你处理了不可落子点，也就是说如果某一步 所落的子的上面恰是不可落子点，那么UI工程中的代码就已经将该列的top值又进行了一次减一操作， 所以在你的代码中也可以根本不使用noX和noY这两个参数，完全认为top数组就是当前每列的顶部即可, 当然如果你想使用lastX,lastY参数，有可能就要同时考虑noX和noY了) 以上参数实际上包含了当前状态(M N _top _board)以及历史信息(lastX lastY),你要做的就是在这些信息下给出尽可能明智的落子点	output: 你的落子点Point */extern "C" Point* getPoint(const int M, const int N, const int* top, const int* _board,                           const int lastX, const int lastY, const int noX, const int noY){    /*     不要更改这段代码     */    clock_t start=clock();                  //计算时间用    srand(time(NULL));    int x = -1, y = -1;                     //最终将你的落子点存到x,y中    int** board = new int*[M];    for(int i = 0; i < M; i++){        board[i] = new int[N];        for(int j = 0; j < N; j++){            board[i][j] = _board[i * N + j];        }    }        /*     根据你自己的策略来返回落子点,也就是根据你的策略完成对x,y的赋值     该部分对参数使用没有限制，为了方便实现，你可以定义自己新的类、.h文件、.cpp文件     */    //Add your own code below    /*     //a naive example     for (int i = N-1; i >= 0; i--) {     if (top[i] > 0) {     x = top[i] - 1;     y = i;     break;     }     }     */        board1 = new int*[M];    for(int i = 0; i < M; i++)        board1[i] = new int[N];    m = M;    n = N;    nx = noX;    ny = noY;                               //大小和禁止的点    p = 0;    l[0] = -1;    user[0] = 0;    re[0] = -2;        for (int z = 0; z < 600000; z++)    {        if ((double)(clock() - start) / CLOCKS_PER_SEC > 2.3)//卡时间            break;                for (int i = 0; i < m; i++)         //复制棋盘            for (int j = 0; j < n; j++)                board1[i][j] = board[i][j];        for (int i = 0; i < n; i++)            top1[i] = top[i];                int t = 0;        while (l[t] != -1)                  //treepolicy        {            t = select(t);        }                        if (tot[t] == 0)                    //如果没有遇到过，判定一下结果        {            re[t] = result(xx[t],yy[t],user[t]);        }        if (re[t] != -2)                    //如果棋局结束        {            int temp = re[t];            while (t != 0)            {                tot[t]++;                win[t] += temp;                t = fa[t];            }            tot[0]++;            continue;        }                l[t] = p + 1;        for (int i = 0; i < n; i++)         //开新的结点        {            if (top1[i] > 0)            {                l[++p] = -1;                win[p] = tot[p] = 0;                fa[p] = t;                user[p] = !user[t];         //与上一步不同                xx[p] = top1[i] - 1;                yy[p] = i;                re[p] = -2;                 //假装全没有结束            }        }        r[t] = p;                int k = rand() % (r[t] - l[t] + 1) + l[t];//随便找一个点落子        play(xx[k],yy[k],user[k]);        int res = result(xx[k],yy[k],user[k]);//加入结束判定        re[k] = res;        bool u = !user[k];                while (res == -2)                   //没有结束的时候，        {            int y1 = rand() % n, x1;            while (top1[y1] == 0)                y1 = rand() % n;            x1 = top1[y1] - 1;            play(x1,y1,u);                        res = result(x1,y1,u);            u = !u;        }        t = k;                while (t != 0)                      //胜场往回增加        {            tot[t]++;            win[t] += res;            t = fa[t];        }        tot[0]++;    }        double max = -100;    int ans;    for (int i = l[0]; i <= r[0]; i++)      //计算选出最好的落子点    {        double temp = (double)win[i] / (double)tot[i];        if (temp > max)        {            max = temp;            ans = i;        }    }    x = xx[ans];    y = yy[ans];    clearArray(M, N, board1);        /*     不要更改这段代码     */    clearArray(M, N, board);    return new Point(x, y);}/*	getPoint函数返回的Point指针是在本dll模块中声明的，为避免产生堆错误，应在外部调用本dll中的	函数来释放空间，而不应该在外部直接delete */extern "C" void clearPoint(Point* p){    delete p;    return;}/*	清除top和board数组 */void clearArray(int M, int N, int** board){    for(int i = 0; i < M; i++){        delete[] board[i];    }    delete[] board;}/*	添加你自己的辅助函数，你可以声明自己的类、函数，添加新的.h .cpp文件来辅助实现你的想法 */int select(int t){    double m = -100000, uct;    int ans;    for (int i = l[t]; i <= r[t]; i++)    {        if (user[t] == 0)            uct = (double)win[i] / ((double)tot[i] + eps) + c * sqrt(2 * log((double)tot[fa[i]] + 1.001) / ((double)tot[i] + eps)) ;        else uct = -(double)win[i] / ((double)tot[i] + eps) + c * sqrt(2 * log((double)tot[fa[i]] + 1.001) / ((double)tot[i] + eps)) ;        if (uct > m)        {            m = uct;            ans = i;        }    }        play(xx[ans],yy[ans],user[ans]);    return ans;}void play(int x,int y,bool u)               //下棋，遇见不能下的就往上{    board1[x][y] = u + 1;    top1[y]--;    if (x == nx + 1 && y == ny)        top1[y]--;}int result(int x,int y,bool u){    if (u == 0 && userWin(x,y,m,n,board1))        return -1;    if (u == 1 && machineWin(x,y,m,n,board1))        return 1;    if (isTie(n,top1))        return 0;    return -2;}